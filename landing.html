      // Reset Model button logic
      const resetBtn = document.getElementById('selfplay-reset');
      if (resetBtn){
        resetBtn.addEventListener('click', async ()=>{
          if (!confirm('Reset model weights? This clears all learned adjustments.')) return;
          if (typeof tf === 'undefined') return;
          model = tf.sequential();
          model.add(tf.layers.dense({inputShape:[773],units:96,activation:'relu'}));
          model.add(tf.layers.dense({units:48,activation:'relu'}));
          model.add(tf.layers.dense({units:1,activation:'tanh'}));
          model.compile({optimizer:'adam',loss:'meanSquaredError'});
          try { await model.save('indexeddb://tf-chess-eval'); localStorage.setItem('tfEngineModelSaved','1'); } catch(_){}
          updateWeights();
          logProgress('Model reset.');
        });
      }
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <label for="selfplay-games" style="font-size:12px;font-weight:600;">Games:</label>
        <input id="selfplay-games" type="number" min="1" max="500" value="25" style="width:80px;padding:4px 6px;border:1px solid var(--panel-border);border-radius:6px;background:var(--history-even);" />
        <button id="selfplay-start" type="button" style="padding:6px 14px;border:none;background:var(--panel-border);color:var(--square-light);font-weight:600;border-radius:6px;cursor:pointer;">Start Self-Play</button>
        <button id="selfplay-cancel" type="button" disabled style="padding:6px 10px;border:none;background:#777;color:#fff;font-weight:600;border-radius:6px;cursor:not-allowed;">Cancel</button>
        <button id="selfplay-reset" type="button" style="padding:6px 10px;border:none;background:#c24747;color:#fff;font-weight:600;border-radius:6px;cursor:pointer;">Reset Model</button>
      </div>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess – Choose Side</title>
  <link rel="stylesheet" href="styles.css?v=20250903" />
  <!-- TensorFlow.js so we can show current saved model weights -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <style>
    .landing-container { max-width:420px; margin:60px auto; background: var(--panel-bg); border:2px solid var(--panel-border); border-radius:12px; padding:32px 36px 40px; font-family:'Roboto',sans-serif; box-shadow:0 6px 18px rgba(0,0,0,.18); }
    .landing-container h1 { margin:0 0 12px; font-size:24px; font-weight:600; text-align:center; color: var(--text-color); }
    .landing-container p { margin:0 0 28px; text-align:center; line-height:1.4; }
    .choose-grid { display:flex; gap:18px; justify-content:center; }
    .side-card { flex:1; min-width:140px; background: linear-gradient(135deg,var(--square-light),var(--history-even)); border:2px solid var(--panel-border); border-radius:10px; padding:14px 12px 16px; display:flex; flex-direction:column; align-items:center; gap:10px; position:relative; transition:.35s box-shadow,.35s transform; cursor:pointer; }
    .side-card:hover { box-shadow:0 4px 10px rgba(0,0,0,.25); transform: translateY(-4px); }
    .side-card.black { background: linear-gradient(135deg,var(--square-dark),#2d1d15); color: var(--square-light); }
    .side-card .label { font-size:18px; font-weight:600; }
    .go-btn { all:unset; cursor:pointer; font-size:14px; padding:8px 16px; background: var(--panel-border); color: var(--square-light); border-radius:6px; font-weight:600; letter-spacing:.5px; box-shadow:0 2px 6px rgba(0,0,0,.25); transition: background .3s, transform .25s; }
    .side-card.black .go-btn { background: var(--square-light); color: var(--square-dark); }
    .go-btn:hover { background: var(--accent-red); transform: translateY(-2px); }
    .note { margin-top:22px; font-size:12px; text-align:center; opacity:.8; }
    .footer-links { margin-top:28px; text-align:center; font-size:12px; }
    .footer-links a { color: var(--accent-red); text-decoration:none; }
  .footer-links a:hover { text-decoration:underline; }
  .time-btn { all:unset; background: var(--square-light); color: var(--square-dark); padding:6px 12px; border:2px solid var(--panel-border); border-radius:6px; font-size:13px; font-weight:600; cursor:pointer; min-width:70px; text-align:center; box-shadow:0 1px 3px rgba(0,0,0,.25); transition:.25s background,.25s transform; }
  .time-btn:hover { background: var(--history-even); transform: translateY(-2px); }
  .time-btn.selected { background: var(--panel-border); color: var(--square-light); box-shadow:0 2px 6px rgba(0,0,0,.3); }
  body.dark .time-btn { background: var(--square-dark); color: var(--square-light); border-color: var(--square-light); }
  body.dark .time-btn.selected { background: var(--square-light); color: var(--square-dark); }
  </style>
</head>
<body>
  <div class="landing-container">
    <h1>Play Chess</h1>
  <p>Select your side and a time control. You're playing against a learning AI that improves as you play.</p>
    <div class="time-select" aria-label="Choose time control" style="margin:0 0 26px;">
      <div style="font-size:14px;font-weight:600;margin:0 0 8px; text-align:center;">Time Control</div>
      <div class="time-options" style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;">
        <button type="button" class="time-btn selected" data-mins="0" aria-pressed="true" title="Unlimited / No clock">Unlimited</button>
        <button type="button" class="time-btn" data-mins="1" aria-pressed="false" title="1 minute blitz">1</button>
        <button type="button" class="time-btn" data-mins="3" aria-pressed="false" title="3 minute blitz">3</button>
        <button type="button" class="time-btn" data-mins="5" aria-pressed="false" title="5 minute blitz">5</button>
      </div>
    </div>
    <div class="choose-grid">
      <div class="side-card white" data-color="White" tabindex="0" role="button" aria-label="Play as White">
        <div class="label">White</div>
        <button class="go-btn" type="button">Start →</button>
      </div>
      <div class="side-card black" data-color="Black" tabindex="0" role="button" aria-label="Play as Black">
        <div class="label">Black</div>
        <button class="go-btn" type="button">Start →</button>
      </div>
    </div>
  <div class="note">Note: White moves first. Choosing Black only flips orientation. The AI stores games locally and trains after each result.</div>
    <div class="footer-links"><a href="index.html">Skip (default White)</a></div>
  </div>
  <!-- Model Weights Preview Panel -->
  <div id="landing-weights-panel" aria-label="Current model weights" role="region" style="max-width:420px;margin:26px auto 60px;background:var(--panel-bg);border:2px solid var(--panel-border);border-radius:12px;padding:18px 20px 22px;box-shadow:0 6px 18px rgba(0,0,0,.18);font-family:'Roboto',sans-serif;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px;">
      <div style="font-size:18px;font-weight:600;">Model Weights</div>
      <div style="display:flex;gap:6px;">
        <button id="landing-refresh-weights-btn" type="button" class="model-refresh-btn" style="border:none;background:var(--panel-border);color:var(--square-light);padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600;">↻</button>
      </div>
    </div>
    <div id="landing-weights-meta" class="model-meta" style="font-size:12px;opacity:.85;margin-bottom:8px;">Loading model...</div>
    <div class="model-weights-wrapper" style="max-height:260px;overflow:auto;">
      <table class="model-weights" style="width:100%;border-collapse:collapse;font-size:13px;">
        <thead><tr><th style="text-align:left;padding:4px 6px;">Feature</th><th style="text-align:right;padding:4px 6px;">W</th><th style="text-align:right;padding:4px 6px;">Δ</th></tr></thead>
        <tbody id="landing-weight-body"></tbody>
      </table>
    </div>
    <div style="font-size:11px;opacity:.7;margin-top:8px;">Preview of first-layer aggregated magnitudes. Updated from saved local model.</div>
    <div id="selfplay-panel" style="margin-top:18px;padding-top:14px;border-top:1px solid var(--panel-border);">
      <div style="font-weight:600;font-size:14px;margin-bottom:6px;display:flex;align-items:center;gap:8px;">Self-Play Training</div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <label for="selfplay-games" style="font-size:12px;font-weight:600;">Games:</label>
        <input id="selfplay-games" type="number" min="1" max="500" value="25" style="width:80px;padding:4px 6px;border:1px solid var(--panel-border);border-radius:6px;background:var(--history-even);" />
        <button id="selfplay-start" type="button" style="padding:6px 14px;border:none;background:var(--panel-border);color:var(--square-light);font-weight:600;border-radius:6px;cursor:pointer;">Start Self-Play</button>
        <button id="selfplay-cancel" type="button" disabled style="padding:6px 10px;border:none;background:#777;color:#fff;font-weight:600;border-radius:6px;cursor:not-allowed;">Cancel</button>
      </div>
      <div id="selfplay-progress" style="margin-top:10px;font-size:12px;line-height:1.4;min-height:34px;white-space:pre-wrap;font-family:monospace;"></div>
    </div>
  </div>
  <script>
    (function(){
      const cards = document.querySelectorAll('.side-card');
      function launch(color){
        const sel = document.querySelector('.time-btn.selected');
        const minutes = sel ? parseInt(sel.dataset.mins,10) : 0;
        try {
          localStorage.setItem('playerColor', color);
          localStorage.setItem('timeControlMinutes', String(minutes));
          console.log('[landing] stored playerColor =', color);
          console.log('[landing] stored timeControlMinutes =', minutes);
        } catch(err) { console.warn('localStorage failed', err); }
        window.location.href = 'index.html?side=' + encodeURIComponent(color) + '&tc=' + minutes;
      }
      cards.forEach(card => {
        const color = card.getAttribute('data-color') || 'White';
        const btn = card.querySelector('.go-btn');
        card.addEventListener('click', () => launch(color));
        if (btn) btn.addEventListener('click', e => { e.stopPropagation(); launch(color); });
        card.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); launch(color); }});
      });
      // time control selection
      document.querySelectorAll('.time-btn').forEach(button => {
        button.addEventListener('click', () => {
          document.querySelectorAll('.time-btn').forEach(b=>{ b.classList.remove('selected'); b.setAttribute('aria-pressed','false'); });
          button.classList.add('selected');
          button.setAttribute('aria-pressed','true');
        });
      });
    })();
  </script>
  <script>
    (function(){
      const features = ['Material','Mobility','KingSafety','CenterControl','PawnStructure','PieceActivity','Pawn','Knight','Bishop','Rook','Queen','King'];
      const tbody = document.getElementById('landing-weight-body');
      if (tbody){
        tbody.innerHTML = features.map(f=>`<tr><td data-f="${f}" style="padding:3px 6px;">${f}</td><td data-w="${f}" style="padding:3px 6px;text-align:right;font-variant-numeric:tabular-nums;">...</td><td data-d="${f}" style="padding:3px 6px;text-align:right;">—</td></tr>`).join('');
      }
      const meta = document.getElementById('landing-weights-meta');
      let model=null; let modelReady=false; let loading=false;
      async function ensureModel(){
        if (modelReady) return model;
        if (typeof tf === 'undefined'){ if (meta) meta.textContent='tf.js not loaded'; return null; }
        loading=true;
        try {
          const flag = localStorage.getItem('tfEngineModelSaved');
          if (flag){
            try { model = await tf.loadLayersModel('indexeddb://tf-chess-eval'); } catch(e){ console.warn('[landing] load failed', e); }
          }
          if (!model){
            model = tf.sequential();
            model.add(tf.layers.dense({inputShape:[773],units:96,activation:'relu'}));
            model.add(tf.layers.dense({units:48,activation:'relu'}));
            model.add(tf.layers.dense({units:1,activation:'tanh'}));
            model.compile({optimizer:'adam',loss:'meanSquaredError'});
            try { await model.save('indexeddb://tf-chess-eval'); localStorage.setItem('tfEngineModelSaved','1'); } catch(_){}
          } else if (!model.optimizer) {
            model.compile({optimizer:'adam',loss:'meanSquaredError'});
          }
          modelReady=true;
          return model;
        } finally { loading=false; }
      }
      function updateWeights(){
        if (!model){ return; }
        const first = model.layers[0]; if (!first){ return; }
        const w = first.getWeights()[0]; if (!w) return;
        const data = w.dataSync(); const inputDim = w.shape[0]; const units = w.shape[1];
        function avgRows(rs,re){ let sum=0,c=0; for (let r=rs;r<re && r<inputDim;r++){ const base=r*units; for (let u=0;u<units;u++){ sum+=Math.abs(data[base+u]); c++; } } return c?sum/c:0; }
        function planeStart(p){ return p*64; } function planeEnd(p){ return p*64+64; }
        function avgPlane(p){ return avgRows(planeStart(p), planeEnd(p)); }
        function combine(planes){ let s=0,c=0; planes.forEach(pl=>{ s+=avgPlane(pl); c++; }); return c? s/c:0; }
        const centerSquares=[27,28,35,36];
        function avgCenterAllPlanes(){ let s=0,c=0; for (let pl=0;pl<12;pl++){ centerSquares.forEach(idx=>{ const row=pl*64+idx; if (row<inputDim){ const base=row*units; for (let u=0;u<units;u++){ s+=Math.abs(data[base+u]); c++; } } }); } return c? s/c:0; }
        const featureValues={
          Material: avgRows(0,768),
          Mobility: combine([1,2,3,4,7,8,9,10]),
          KingSafety: combine([5,11]),
          CenterControl: avgCenterAllPlanes(),
          PawnStructure: combine([0,6]),
          PieceActivity: combine([0,1,2,3,4,6,7,8,9,10]),
          Pawn: combine([0,6]),
          Knight: combine([1,7]),
          Bishop: combine([2,8]),
          Rook: combine([3,9]),
          Queen: combine([4,10]),
          King: combine([5,11])
        };
        // Load previous snapshot for Δ
        let prev = null; try { const raw = localStorage.getItem('tfFeatureSnapshot'); if (raw) prev = JSON.parse(raw); } catch(_){}
        features.forEach(f=>{
          const wtd = tbody && tbody.querySelector(`td[data-w='${f}']`);
          const dtd = tbody && tbody.querySelector(`td[data-d='${f}']`);
          if (wtd && featureValues[f]!=null) wtd.textContent = featureValues[f].toFixed(4);
          if (dtd){
            if (prev && typeof prev[f] === 'number'){
              const d = featureValues[f] - prev[f];
              const s = (d>=0?'+':'') + d.toFixed(4);
              dtd.textContent = s; dtd.style.color = d>0 ? '#2d6a2d' : (d<0 ? '#8c1f1f' : '');
            } else { dtd.textContent = '—'; dtd.style.color=''; }
          }
        });
        if (meta) meta.innerHTML = 'Engine: TFValueNet <span style="opacity:.65;">(saved)</span><br><span class="note">Layer0 avg rows:'+inputDim+' units:'+units+'</span>';
        // Save snapshot so next visit can show Δ
        try { localStorage.setItem('tfFeatureSnapshot', JSON.stringify(featureValues)); } catch(_){}
      }
      async function init(){
        if (meta) meta.textContent='Loading model...';
        await ensureModel();
        if (!model){ if (meta) meta.textContent='Model unavailable'; return; }
        updateWeights();
      }
      init();
      const refreshBtn = document.getElementById('landing-refresh-weights-btn');
      if (refreshBtn){ refreshBtn.addEventListener('click', async ()=>{ if (loading) return; if (meta) meta.textContent='Refreshing...'; await ensureModel(); updateWeights(); }); }

      // ---------- Self-Play Training Logic (simplified) ----------
      const startBtn = document.getElementById('selfplay-start');
      const cancelBtn = document.getElementById('selfplay-cancel');
      const gamesInput = document.getElementById('selfplay-games');
      const progressEl = document.getElementById('selfplay-progress');
      let cancelFlag = false;
      let selfPlaySamples = [];

      function logProgress(msg){ if (progressEl) progressEl.textContent = msg; }

      function cloneBoard(b){ return b.map(r=>r.slice()); }
      function startBoard(){
        return [
          ['Black Rook','Black Knight','Black Bishop','Black Queen','Black King','Black Bishop','Black Knight','Black Rook'],
          Array(8).fill('Black Pawn'),
          Array(8).fill(null),Array(8).fill(null),Array(8).fill(null),Array(8).fill(null),
          Array(8).fill('White Pawn'),
          ['White Rook','White Knight','White Bishop','White Queen','White King','White Bishop','White Knight','White Rook']
        ];
      }
      function materialDiff(board){ const values={Pawn:1,Knight:3,Bishop:3,Rook:5,Queen:9}; let w=0,b=0; for (let r=0;r<8;r++){ for(let c=0;c<8;c++){ const p=board[r][c]; if(!p) continue; const [color,type]=p.split(' '); if(!values[type]) continue; if(color==='White') w+=values[type]; else b+=values[type]; } } return w-b; }
      function generateMoves(board, color){
        const moves=[]; const opponent = color==='White'?'Black':'White';
        for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p=board[r][c]; if(!p||!p.includes(color)) continue; const type=p.split(' ')[1];
          if (type==='Pawn'){
            const dir = color==='White'? -1:1; const nr=r+dir; if (nr>=0&&nr<8){ if(!board[nr][c]) moves.push({r,c,nr,nc:c}); const ncL=c-1, ncR=c+1; [ncL,ncR].forEach(nc=>{ if(nc>=0&&nc<8){ const tp=board[nr][nc]; if (tp&&tp.includes(opponent)) moves.push({r,c,nr,nc}); } }); }
          } else if (type==='Knight'){
            const deltas=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]; deltas.forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(!tp||tp.includes(opponent)) moves.push({r,c,nr,nc}); }});
          } else if (type==='Bishop' || type==='Rook' || type==='Queen'){
            const dirs=[]; if (type==='Bishop'||type==='Queen') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if (type==='Rook'||type==='Queen') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
            dirs.forEach(([dr,dc])=>{ let nr=r+dr,nc=c+dc; while(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(!tp){ moves.push({r,c,nr,nc}); } else { if (tp.includes(opponent)) moves.push({r,c,nr,nc}); break; } nr+=dr; nc+=dc; } });
          } else if (type==='King'){
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc) continue; const nr=r+dr,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(!tp||tp.includes(opponent)) moves.push({r,c,nr,nc}); }}
          }
        }
        return moves;
      }
      function encodeBoard(board, turnColor){
        const mapping={Pawn:0,Knight:1,Bishop:2,Rook:3,Queen:4,King:5}; const arr=new Float32Array(773);
        for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p=board[r][c]; if(!p) continue; const [color,type]=p.split(' '); const base=mapping[type]; const colorOffset=color==='White'?0:6; const idx=(colorOffset+base)*64 + (r*8+c); arr[idx]=1; }
        arr[768]= (turnColor==='White')?1:0; return arr;
      }
      async function selectModelMove(board, color){
        if (!model) return null; const moves=generateMoves(board,color); if (!moves.length) return null; let best=null; let bestScore=-Infinity; const opp=color==='White'?'Black':'White';
        for(const mv of moves){ const piece=board[mv.r][mv.c]; const captured=board[mv.nr][mv.nc]; board[mv.nr][mv.nc]=piece; board[mv.r][mv.c]=null; const enc=encodeBoard(board, opp); const pred=model.predict(tf.tensor2d([Array.from(enc)])); const score=(await pred.data())[0]; pred.dispose(); board[mv.r][mv.c]=piece; board[mv.nr][mv.nc]=captured; if(score>bestScore){ bestScore=score; best=mv; } }
        return best || moves[0];
      }
      async function selfPlayOneGame(gameIndex, totalGames){
        let board=startBoard(); let turnColor='White'; let plies=0; let gamePositions=[]; let outcome=0; // 0 draw baseline
        let movesSincePawnOrCapture = 0;
        let lastMat = materialDiff(board);
        while(true){
          if(cancelFlag) return null;
          // King-capture detection
          let whiteKing=false, blackKing=false;
          for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=board[r][c]; if(p==='White King') whiteKing=true; if(p==='Black King') blackKing=true; }
          if (!whiteKing || !blackKing) break;
          // 50-move rule
          if (movesSincePawnOrCapture >= 50) { outcome=0; break; }
          const moves=generateMoves(board, turnColor);
          if(!moves.length) break;
          const mv= await selectModelMove(board, turnColor) || moves[Math.floor(Math.random()*moves.length)];
          const piece=board[mv.r][mv.c];
          const captured=board[mv.nr][mv.nc];
          board[mv.nr][mv.nc]=piece; board[mv.r][mv.c]=null;
          // sample
          const enc=encodeBoard(board, turnColor==='White'?'Black':'White');
          const mat=materialDiff(board);
          const target=Math.max(-1, Math.min(1, mat/20));
          gamePositions.push({input:enc, target});
          // 50-move rule update
          if (piece.includes('Pawn') || captured) movesSincePawnOrCapture=0; else movesSincePawnOrCapture++;
          turnColor = (turnColor==='White')?'Black':'White';
          plies++;
        }
        // Outcome heuristic by material difference or king capture
        let whiteKing=false, blackKing=false;
        for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=board[r][c]; if(p==='White King') whiteKing=true; if(p==='Black King') blackKing=true; }
        if (!whiteKing && blackKing) outcome=-1;
        else if (whiteKing && !blackKing) outcome=1;
        else {
          const finalMat = materialDiff(board);
          if (finalMat>0) outcome=1; else if (finalMat<0) outcome=-1; else outcome=0;
        }
        // Label last up to 30 positions with outcome
        const labelCount = Math.min(30, gamePositions.length); for (let i=gamePositions.length - labelCount; i<gamePositions.length; i++){ gamePositions[i].target = outcome; }
        selfPlaySamples = selfPlaySamples.concat(gamePositions);
        logProgress(`Game ${gameIndex+1}/${totalGames}\nPositions: ${gamePositions.length} (total samples ${selfPlaySamples.length})`);
        return {positions: gamePositions.length, outcome};
      }
      async function trainOnSelfPlay(){
        if (!selfPlaySamples.length) return; await ensureModel(); if(!model) return; if (!model.optimizer) model.compile({optimizer:'adam',loss:'meanSquaredError'});
        const xs=tf.tensor2d(selfPlaySamples.map(s=>Array.from(s.input))); const ys=tf.tensor2d(selfPlaySamples.map(s=>[s.target]));
        const before=(()=>{ try{ const w=model.layers[0].getWeights()[0].dataSync(); let s=0; for(let i=0;i<w.length;i++) s+=Math.abs(w[i]); return s; } catch(_){ return 0; } })();
        logProgress(prev=> (prev?prev+'\n':'') + 'Training on '+selfPlaySamples.length+' samples...');
        await model.fit(xs, ys, {epochs:3,batchSize:Math.min(64,selfPlaySamples.length),verbose:0,callbacks:{onEpochEnd:(e,l)=>{ console.log('[selfplay] epoch',e+1,'loss',Number(l.loss).toFixed(5)); }}});
        xs.dispose(); ys.dispose();
        try { await model.save('indexeddb://tf-chess-eval'); localStorage.setItem('tfEngineModelSaved','1'); } catch(_){ }
        updateWeights();
        const after=(()=>{ try{ const w=model.layers[0].getWeights()[0].dataSync(); let s=0; for(let i=0;i<w.length;i++) s+=Math.abs(w[i]); return s; } catch(_){ return 0; } })();
        logProgress(progressEl.textContent + `\nTraining complete. Δ checksum ${(after-before).toFixed(6)}`);
        selfPlaySamples=[];
      }
      async function runSelfPlay(){
        await ensureModel(); if (!model){ logProgress('Model unavailable.'); return; }
        cancelFlag=false; const total = Math.max(1, Math.min(500, parseInt(gamesInput.value,10)||1));
        startBtn.disabled=true; cancelBtn.disabled=false; cancelBtn.style.cursor='pointer'; cancelBtn.style.background='#c24747';
        logProgress('Starting self-play for '+total+' games...');
        for (let g=0; g<total; g++){
          if (cancelFlag){ logProgress('Cancelled at game '+(g+1)); break; }
            await selfPlayOneGame(g,total);
            // Yield to UI
            await new Promise(res=> setTimeout(res, 0));
        }
        if (!cancelFlag) { await trainOnSelfPlay(); }
        startBtn.disabled=false; cancelBtn.disabled=true; cancelBtn.style.background='#777'; cancelBtn.style.cursor='not-allowed';
      }
      if (startBtn){ startBtn.addEventListener('click', ()=> runSelfPlay()); }
      if (cancelBtn){ cancelBtn.addEventListener('click', ()=>{ cancelFlag=true; cancelBtn.disabled=true; cancelBtn.style.background='#777'; cancelBtn.style.cursor='not-allowed'; }); }
    })();
  </script>
</body>
</html>
