<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess – Choose Side</title>
  <link rel="stylesheet" href="styles.css?v=20250903" />
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <style>
    .landing-container { max-width:420px; margin:60px auto; background: var(--panel-bg); border:2px solid var(--panel-border); border-radius:12px; padding:32px 36px 40px; font-family:'Roboto',sans-serif; box-shadow:0 6px 18px rgba(0,0,0,.18); }
    .landing-container h1 { margin:0 0 12px; font-size:24px; font-weight:600; text-align:center; color: var(--text-color); }
    .landing-container p { margin:0 0 28px; text-align:center; line-height:1.4; }
    .choose-grid { display:flex; gap:18px; justify-content:center; }
    .side-card { flex:1; min-width:140px; background: linear-gradient(135deg,var(--square-light),var(--history-even)); border:2px solid var(--panel-border); border-radius:10px; padding:14px 12px 16px; display:flex; flex-direction:column; align-items:center; gap:10px; position:relative; transition:.35s box-shadow,.35s transform; cursor:pointer; }
    .side-card:hover { box-shadow:0 4px 10px rgba(0,0,0,.25); transform: translateY(-4px); }
    .side-card.black { background: linear-gradient(135deg,var(--square-dark),#2d1d15); color: var(--square-light); }
    .side-card .label { font-size:18px; font-weight:600; }
    .go-btn { all:unset; cursor:pointer; font-size:14px; padding:8px 16px; background: var(--panel-border); color: var(--square-light); border-radius:6px; font-weight:600; letter-spacing:.5px; box-shadow:0 2px 6px rgba(0,0,0,.25); transition: background .3s, transform .25s; }
    .side-card.black .go-btn { background: var(--square-light); color: var(--square-dark); }
    .go-btn:hover { background: var(--accent-red); transform: translateY(-2px); }
    .note { margin-top:22px; font-size:12px; text-align:center; opacity:.8; }
    .footer-links { margin-top:28px; text-align:center; font-size:12px; }
    .footer-links a { color: var(--accent-red); text-decoration:none; }
    .footer-links a:hover { text-decoration:underline; }
    .time-btn { all:unset; background: var(--square-light); color: var(--square-dark); padding:6px 12px; border:2px solid var(--panel-border); border-radius:6px; font-size:13px; font-weight:600; cursor:pointer; min-width:70px; text-align:center; box-shadow:0 1px 3px rgba(0,0,0,.25); transition:.25s background,.25s transform; }
    .time-btn:hover { background: var(--history-even); transform: translateY(-2px); }
    .time-btn.selected { background: var(--panel-border); color: var(--square-light); box-shadow:0 2px 6px rgba(0,0,0,.3); }
    body.dark .time-btn { background: var(--square-dark); color: var(--square-light); border-color: var(--square-light); }
    body.dark .time-btn.selected { background: var(--square-light); color: var(--square-dark); }
  </style>
</head>
<body>
  <div class="landing-container">
    <h1>Play Chess</h1>
    <p>Select your side and a time control. You're playing against a learning AI that improves as you play.</p>
    <div class="time-select" aria-label="Choose time control" style="margin:0 0 26px;">
      <div style="font-size:14px;font-weight:600;margin:0 0 8px; text-align:center;">Time Control</div>
      <div class="time-options" style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;">
        <button type="button" class="time-btn selected" data-mins="0" aria-pressed="true" title="Unlimited / No clock">Unlimited</button>
        <button type="button" class="time-btn" data-mins="1" aria-pressed="false" title="1 minute blitz">1</button>
        <button type="button" class="time-btn" data-mins="3" aria-pressed="false" title="3 minute blitz">3</button>
        <button type="button" class="time-btn" data-mins="5" aria-pressed="false" title="5 minute blitz">5</button>
      </div>
    </div>
    <div class="choose-grid">
      <div class="side-card white" data-color="White" tabindex="0" role="button" aria-label="Play as White">
        <div class="label">White</div>
        <button class="go-btn" type="button">Start →</button>
      </div>
      <div class="side-card black" data-color="Black" tabindex="0" role="button" aria-label="Play as Black">
        <div class="label">Black</div>
        <button class="go-btn" type="button">Start →</button>
      </div>
    </div>
    <div class="note">Note: White moves first. Choosing Black only flips orientation. The AI stores games locally and trains after each result.</div>
    <div class="footer-links"><a href="index.html">Skip (default White)</a></div>
  </div>
  <div id="landing-weights-panel" aria-label="Current model weights" role="region" style="max-width:420px;margin:26px auto 60px;background:var(--panel-bg);border:2px solid var(--panel-border);border-radius:12px;padding:18px 20px 22px;box-shadow:0 6px 18px rgba(0,0,0,.18);font-family:'Roboto',sans-serif;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px;">
      <div style="font-size:18px;font-weight:600;">Model Weights</div>
      <div style="display:flex;gap:6px;">
        <button id="landing-refresh-weights-btn" type="button" style="border:none;background:var(--panel-border);color:var(--square-light);padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600;">↻</button>
      </div>
    </div>
    <div id="landing-weights-meta" style="font-size:12px;opacity:.85;margin-bottom:8px;">Loading model...</div>
    <div style="max-height:260px;overflow:auto;">
      <table style="width:100%;border-collapse:collapse;font-size:13px;">
        <thead><tr><th style="text-align:left;padding:4px 6px;">Feature</th><th style="text-align:right;padding:4px 6px;">W</th><th style="text-align:right;padding:4px 6px;">Δ</th></tr></thead>
        <tbody id="landing-weight-body"></tbody>
      </table>
    </div>
    <div style="font-size:11px;opacity:.7;margin-top:8px;">Preview of first-layer aggregated magnitudes. Updated from saved local model.</div>
    <div id="selfplay-panel" style="margin-top:18px;padding-top:14px;border-top:1px solid var(--panel-border);">
      <div style="font-weight:600;font-size:14px;margin-bottom:6px;display:flex;align-items:center;gap:8px;">Self-Play Training</div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <label for="selfplay-games" style="font-size:12px;font-weight:600;">Games:</label>
        <input id="selfplay-games" type="number" min="1" max="500" value="25" style="width:80px;padding:4px 6px;border:1px solid var(--panel-border);border-radius:6px;background:var(--history-even);" />
        <button id="selfplay-start" type="button" style="padding:6px 14px;border:none;background:var(--panel-border);color:var(--square-light);font-weight:600;border-radius:6px;cursor:pointer;">Start Self-Play</button>
        <button id="selfplay-cancel" type="button" disabled style="padding:6px 10px;border:none;background:#777;color:#fff;font-weight:600;border-radius:6px;cursor:not-allowed;">Cancel</button>
        <button id="selfplay-reset" type="button" style="padding:6px 10px;border:none;background:#c24747;color:#fff;font-weight:600;border-radius:6px;cursor:pointer;">Reset Model</button>
      </div>
      <div id="selfplay-progress" style="margin-top:10px;font-size:12px;line-height:1.4;min-height:34px;white-space:pre-wrap;font-family:monospace;"></div>
      <div id="selfplay-visual" style="margin-top:14px;padding-top:10px;border-top:1px dashed var(--panel-border);">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
          <div style="font-weight:600;font-size:13px;">Live Self-Play Board</div>
          <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer;">
            <input type="checkbox" id="selfplay-visual-toggle" checked style="margin:0;"> Show
          </label>
        </div>
        <div id="mini-board" style="display:grid;grid-template-columns:repeat(8,22px);grid-auto-rows:22px;border:1px solid var(--panel-border);border-radius:6px;overflow:hidden;width:max-content;box-shadow:0 1px 3px rgba(0,0,0,.25);"></div>
        <div id="mini-board-status" style="font-size:11px;margin-top:6px;min-height:16px;opacity:.85;"></div>
      </div>
    </div>
  </div>

  <script>
  // Navigation & time control selection
  (function(){
    const cards = document.querySelectorAll('.side-card');
    function launch(color){
      const sel = document.querySelector('.time-btn.selected');
      const minutes = sel ? parseInt(sel.dataset.mins,10) : 0;
      try {
        localStorage.setItem('playerColor', color);
        localStorage.setItem('timeControlMinutes', String(minutes));
      } catch(err) { }
      window.location.href = 'index.html?side=' + encodeURIComponent(color) + '&tc=' + minutes;
    }
    cards.forEach(card => {
      const color = card.getAttribute('data-color') || 'White';
      const btn = card.querySelector('.go-btn');
      card.addEventListener('click', () => launch(color));
      if (btn) btn.addEventListener('click', e => { e.stopPropagation(); launch(color); });
      card.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); launch(color); }});
    });
    document.querySelectorAll('.time-btn').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.time-btn').forEach(b=>{ b.classList.remove('selected'); b.setAttribute('aria-pressed','false'); });
        button.classList.add('selected');
        button.setAttribute('aria-pressed','true');
      });
    });
  })();
  </script>

  <script>
  // Weights panel + self-play
  (function(){
    const features = ['Material','Mobility','KingSafety','CenterControl','PawnStructure','PieceActivity','Pawn','Knight','Bishop','Rook','Queen','King'];
    const tbody = document.getElementById('landing-weight-body');
    if (tbody){
      tbody.innerHTML = features.map(f=>`<tr><td data-f="${f}" style="padding:3px 6px;">${f}</td><td data-w="${f}" style="padding:3px 6px;text-align:right;font-variant-numeric:tabular-nums;">...</td><td data-d="${f}" style="padding:3px 6px;text-align:right;">—</td></tr>`).join('');
    }
    const meta = document.getElementById('landing-weights-meta');
    let model=null; let modelReady=false; let loading=false;
    async function ensureModel(){
      if (modelReady) return model;
      if (typeof tf === 'undefined'){ if (meta) meta.textContent='tf.js not loaded'; return null; }
      loading=true;
      try {
        const flag = localStorage.getItem('tfEngineModelSaved');
        if (flag){
          try { model = await tf.loadLayersModel('indexeddb://tf-chess-eval'); } catch(e){ console.warn('[landing] load failed', e); }
        }
        if (!model){
          model = tf.sequential();
          model.add(tf.layers.dense({inputShape:[773],units:96,activation:'relu'}));
          model.add(tf.layers.dense({units:48,activation:'relu'}));
          model.add(tf.layers.dense({units:1,activation:'tanh'}));
          model.compile({optimizer:'adam',loss:'meanSquaredError'});
          try { await model.save('indexeddb://tf-chess-eval'); localStorage.setItem('tfEngineModelSaved','1'); } catch(_){ }
        } else if (!model.optimizer) {
          model.compile({optimizer:'adam',loss:'meanSquaredError'});
        }
        modelReady=true; return model;
      } finally { loading=false; }
    }
    function updateWeights(){
      if (!model) return; const first = model.layers[0]; if(!first) return; const w = first.getWeights()[0]; if(!w) return;
      const data=w.dataSync(); const inputDim=w.shape[0]; const units=w.shape[1];
      function avgRows(rs,re){ let sum=0,c=0; for(let r=rs;r<re && r<inputDim;r++){ const base=r*units; for(let u=0;u<units;u++){ sum+=Math.abs(data[base+u]); c++; } } return c?sum/c:0; }
      function avgPlane(p){ return avgRows(p*64,p*64+64); }
      function combine(planes){ let s=0; planes.forEach(pl=>{ s+=avgPlane(pl); }); return s/planes.length; }
      const centerSquares=[27,28,35,36];
      function avgCenterAllPlanes(){ let s=0,c=0; for (let pl=0;pl<12;pl++){ centerSquares.forEach(idx=>{ const row=pl*64+idx; if(row<inputDim){ const base=row*units; for(let u=0;u<units;u++){ s+=Math.abs(data[base+u]); c++; } } }); } return c? s/c:0; }
      const featureValues={
        Material: avgRows(0,768),
        Mobility: combine([1,2,3,4,7,8,9,10]),
        KingSafety: combine([5,11]),
        CenterControl: avgCenterAllPlanes(),
        PawnStructure: combine([0,6]),
        PieceActivity: combine([0,1,2,3,4,6,7,8,9,10]),
        Pawn: combine([0,6]),
        Knight: combine([1,7]),
        Bishop: combine([2,8]),
        Rook: combine([3,9]),
        Queen: combine([4,10]),
        King: combine([5,11])
      };
      let prev=null; try { const raw=localStorage.getItem('tfFeatureSnapshot'); if(raw) prev=JSON.parse(raw); } catch(_){ }
      function formatDelta(val){
        if (val === 0) return '0';
        const sign = val>0?'+':'-';
        const abs = Math.abs(val);
        for (let p=4; p<=8; p++){
          const fixed = abs.toFixed(p);
          if (parseFloat(fixed) !== 0){
            let trimmed = fixed.replace(/0+$/,'').replace(/\.$/,'');
            return sign + trimmed;
          }
        }
        return sign + '<1e-8';
      }
      features.forEach(f=>{
        const wtd=tbody && tbody.querySelector(`td[data-w='${f}']`);
        const dtd=tbody && tbody.querySelector(`td[data-d='${f}']`);
        if (wtd) wtd.textContent = featureValues[f].toFixed(4);
        if (dtd){
          if (prev && typeof prev[f]==='number'){
            const d = featureValues[f]-prev[f];
            dtd.textContent = formatDelta(d);
            dtd.style.color = d>0 ? '#2d6a2d' : (d<0 ? '#8c1f1f' : '');
            dtd.title = 'Δ ' + d.toPrecision(6);
          } else { dtd.textContent='—'; dtd.style.color=''; dtd.removeAttribute('title'); }
        }
      });
      if (meta) meta.innerHTML = 'Engine: TFValueNet <span style="opacity:.65;">(saved)</span><br><span class="note">Layer0 rows:'+inputDim+' units:'+units+'</span>';
      try { localStorage.setItem('tfFeatureSnapshot', JSON.stringify(featureValues)); } catch(_){ }
    }
    async function init(){ if (meta) meta.textContent='Loading model...'; await ensureModel(); if(!model){ if(meta) meta.textContent='Model unavailable'; return; } updateWeights(); }
    init();
    const refreshBtn=document.getElementById('landing-refresh-weights-btn');
    if (refreshBtn){ refreshBtn.addEventListener('click', async ()=>{ if(loading) return; if(meta) meta.textContent='Refreshing...'; await ensureModel(); updateWeights(); }); }

    // Self-play
    const startBtn=document.getElementById('selfplay-start');
    const cancelBtn=document.getElementById('selfplay-cancel');
    const resetBtn=document.getElementById('selfplay-reset');
    const gamesInput=document.getElementById('selfplay-games');
    const progressEl=document.getElementById('selfplay-progress');
    let cancelFlag=false; let selfPlaySamples=[];
    function logProgress(msg){ if(progressEl) progressEl.textContent=msg; }
    function startBoard(){ return [ ['Black Rook','Black Knight','Black Bishop','Black Queen','Black King','Black Bishop','Black Knight','Black Rook'], Array(8).fill('Black Pawn'), Array(8).fill(null),Array(8).fill(null),Array(8).fill(null),Array(8).fill(null), Array(8).fill('White Pawn'), ['White Rook','White Knight','White Bishop','White Queen','White King','White Bishop','White Knight','White Rook'] ]; }
    function materialDiff(board){ const values={Pawn:1,Knight:3,Bishop:3,Rook:5,Queen:9}; let w=0,b=0; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=board[r][c]; if(!p) continue; const [color,type]=p.split(' '); if(!values[type]) continue; if(color==='White') w+=values[type]; else b+=values[type]; } return w-b; }
    function generateMoves(board,color){ const moves=[]; const opponent=color==='White'?'Black':'White'; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=board[r][c]; if(!p||!p.includes(color)) continue; const type=p.split(' ')[1]; if(type==='Pawn'){ const dir=color==='White'?-1:1; const nr=r+dir; if(nr>=0&&nr<8){ if(!board[nr][c]) moves.push({r,c,nr,nc:c}); [c-1,c+1].forEach(nc=>{ if(nc>=0&&nc<8){ const tp=board[nr][nc]; if(tp&&tp.includes(opponent)) moves.push({r,c,nr,nc}); }}); } } else if(type==='Knight'){ [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]].forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(!tp||tp.includes(opponent)) moves.push({r,c,nr,nc}); }}); } else if (type==='Bishop'||type==='Rook'||type==='Queen'){ const dirs=[]; if(type==='Bishop'||type==='Queen') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if(type==='Rook'||type==='Queen') dirs.push([1,0],[-1,0],[0,1],[0,-1]); dirs.forEach(([dr,dc])=>{ let nr=r+dr,nc=c+dc; while(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(!tp) moves.push({r,c,nr,nc}); else { if(tp.includes(opponent)) moves.push({r,c,nr,nc}); break; } nr+=dr; nc+=dc; } }); } else if(type==='King'){ for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc) continue; const nr=r+dr,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(!tp||tp.includes(opponent)) moves.push({r,c,nr,nc}); }} } } return moves; }
    // --- Self-play legality helpers (filter out moves leaving own king in check) ---
    function isSquareAttacked(board, tr, tc, attacker){
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=board[r][c]; if(!p||!p.includes(attacker)) continue; const type=p.split(' ')[1]; switch(type){
        case 'Pawn': { const dir = attacker==='White'? -1:1; if(r+dir===tr && Math.abs(c-tc)===1) return true; break; }
        case 'Knight': { const dr=Math.abs(r-tr), dc=Math.abs(c-tc); if((dr===2&&dc===1)||(dr===1&&dc===2)) return true; break; }
        case 'Bishop': case 'Rook': case 'Queen': { const dirs=[]; if(type==='Bishop'||type==='Queen') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if(type==='Rook'||type==='Queen') dirs.push([1,0],[-1,0],[0,1],[0,-1]); for(const [dr,dc] of dirs){ let nr=r+dr,nc=c+dc; while(nr>=0&&nr<8&&nc>=0&&nc<8){ const tp=board[nr][nc]; if(nr===tr && nc===tc) return true; if(tp){ break; } nr+=dr; nc+=dc; } } break; }
        case 'King': { if(Math.max(Math.abs(r-tr),Math.abs(c-tc))===1) return true; break; }
      } }
      return false;
    }
    function isKingInCheck(board,color){ let kr=-1,kc=-1; for(let r=0;r<8;r++){ for(let c=0;c<8;c++){ if(board[r][c]===color+' King'){ kr=r; kc=c; break; } } if(kr!==-1) break; } if(kr===-1) return false; const opp=color==='White'?'Black':'White'; return isSquareAttacked(board,kr,kc,opp); }
    function simulate(board, mv){ const clone = board.map(row=>row.slice()); const piece=clone[mv.r][mv.c]; clone[mv.nr][mv.nc]=piece; clone[mv.r][mv.c]=null; return clone; }
    function generateLegalMoves(board,color){ const pseudo=generateMoves(board,color); return pseudo.filter(mv=>{ const nb=simulate(board,mv); return !isKingInCheck(nb,color); }); }
    function encodeBoard(board,turnColor){ const mapping={Pawn:0,Knight:1,Bishop:2,Rook:3,Queen:4,King:5}; const arr=new Float32Array(773); for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=board[r][c]; if(!p) continue; const [color,type]=p.split(' '); const base=mapping[type]; const colorOffset=color==='White'?0:6; const idx=(colorOffset+base)*64 + (r*8+c); arr[idx]=1; } arr[768]=(turnColor==='White')?1:0; return arr; }
    async function selectModelMove(board,color){ if(!model) return null; const moves=generateMoves(board,color); if(!moves.length) return null; let best=null,bestScore=-Infinity; const opp=color==='White'?'Black':'White'; for(const mv of moves){ const piece=board[mv.r][mv.c]; const captured=board[mv.nr][mv.nc]; board[mv.nr][mv.nc]=piece; board[mv.r][mv.c]=null; const enc=encodeBoard(board,opp); const pred=model.predict(tf.tensor2d([Array.from(enc)])); const score=(await pred.data())[0]; pred.dispose(); board[mv.r][mv.c]=piece; board[mv.nr][mv.nc]=captured; if(score>bestScore){ bestScore=score; best=mv; } } return best||moves[0]; }
    // ---- Live mini-board rendering ----
    const miniBoardEl = document.getElementById('mini-board');
    const miniStatusEl = document.getElementById('mini-board-status');
    const miniToggle = document.getElementById('selfplay-visual-toggle');
    let showMini = miniToggle ? miniToggle.checked : true;
    if(miniToggle){ miniToggle.addEventListener('change',()=>{ showMini = miniToggle.checked; if(!showMini){ miniBoardEl.style.opacity='.35'; } else { miniBoardEl.style.opacity='1'; } }); }
    // Build static squares once
    function initMiniBoard(){
      if(!miniBoardEl) return;
      if(miniBoardEl.childElementCount) return; // already
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq=document.createElement('div');
          const light = (r+c)%2===0;
            sq.style.cssText=`width:22px;height:22px;position:relative;background:${light?'#f0d9b5':'#b58863'};display:flex;align-items:center;justify-content:center;`;
          sq.dataset.r=r; sq.dataset.c=c;
          miniBoardEl.appendChild(sq);
        }
      }
    }
    function spriteFor(piece){ if(!piece) return null; return 'sprites/'+piece.replace(/ /g,'_')+'.png'; }
    function renderMini(board, gameIndex, totalGames, ply, turnColor){
      if(!showMini||!miniBoardEl) return;
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq = miniBoardEl.querySelector(`div[data-r='${r}'][data-c='${c}']`);
          if(!sq) continue;
          const piece = board[r][c];
          if(sq.firstChild) sq.removeChild(sq.firstChild);
          if(piece){
            const img=document.createElement('img');
            img.src=spriteFor(piece);
            img.alt=piece;
            img.style.cssText='width:100%;height:100%;object-fit:contain;pointer-events:none;';
            sq.appendChild(img);
          }
        }
      }
      if(miniStatusEl){ miniStatusEl.textContent = `Game ${gameIndex+1}/${totalGames} • Ply ${ply} • To move: ${turnColor}`; }
    }
    initMiniBoard();

  async function selfPlayOneGame(gameIndex,totalGames){
      let board=startBoard(); let turnColor='White'; let gamePositions=[]; let outcome=null; let movesSincePawnOrCapture=0; let ply=0; renderMini(board, gameIndex, totalGames, ply, turnColor);
      const repetitionCounts=Object.create(null);
      function fenKey(b,active){ // placement + active + no castling/ep for repetition simplicity
        const rows=[]; for(let r=0;r<8;r++){ let rowStr='',empty=0; for(let c=0;c<8;c++){ const p=b[r][c]; if(!p){ empty++; continue; } if(empty){ rowStr+=empty; empty=0; } const [color,type]=p.split(' '); const map={King:'k',Queen:'q',Rook:'r',Bishop:'b',Knight:'n',Pawn:'p'}; const ch=map[type]||'?'; rowStr+= (color==='White'? ch.toUpperCase(): ch); } if(empty) rowStr+=empty; rows.push(rowStr); }
        return rows.join('/')+' '+(active==='White'?'w':'b')+' - -';
      }
      function recordRepetition(b,active){ const key=fenKey(b,active); repetitionCounts[key]=(repetitionCounts[key]||0)+1; if(repetitionCounts[key]>=3) return true; return false; }
      // record initial position
      recordRepetition(board,turnColor);
      while(true){
        if(cancelFlag) return null;
        // Kings present?
        let whiteKing=false,blackKing=false; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=board[r][c]; if(p==='White King') whiteKing=true; if(p==='Black King') blackKing=true; }
        if(!whiteKing||!blackKing){ outcome = whiteKing?1:-1; break; }
        if(movesSincePawnOrCapture>=50){ outcome=0; break; }
        const legal=generateLegalMoves(board,turnColor);
        if(!legal.length){
          // checkmate or stalemate
            if(isKingInCheck(board,turnColor)) outcome = (turnColor==='White')? -1 : 1; else outcome = 0;
            break;
        }
        // choose move (model still uses pseudo set; restrict to legal for safety)
        let mv = await selectModelMove(board,turnColor);
        if(!mv || !legal.some(l=>l.r===mv.r && l.c===mv.c && l.nr===mv.nr && l.nc===mv.nc)){
          mv = legal[Math.floor(Math.random()*legal.length)];
        }
        const piece=board[mv.r][mv.c]; const captured=board[mv.nr][mv.nc];
        board[mv.nr][mv.nc]=piece; board[mv.r][mv.c]=null;
        const enc=encodeBoard(board,turnColor==='White'?'Black':'White');
        const mat=materialDiff(board); const target=Math.max(-1,Math.min(1,mat/20));
        gamePositions.push({input:enc,target});
        if(piece.includes('Pawn')||captured) movesSincePawnOrCapture=0; else movesSincePawnOrCapture++;
        turnColor = turnColor==='White'?'Black':'White'; ply++;
        if(recordRepetition(board,turnColor)){ outcome=0; break; }
        renderMini(board, gameIndex, totalGames, ply, turnColor);
        await new Promise(res=>setTimeout(res,0));
      }
      if(outcome==null){ // fallback if somehow not set
        const finalMat=materialDiff(board); outcome = finalMat>0?1: finalMat<0?-1:0;
      }
      // Label final segment with outcome
      const labelCount=Math.min(30,gamePositions.length); for(let i=gamePositions.length-labelCount;i<gamePositions.length;i++){ if(gamePositions[i]) gamePositions[i].target=outcome; }
  // For per-game training, keep only this game's samples in buffer
  selfPlaySamples = gamePositions;
  logProgress(`Game ${gameIndex+1}/${totalGames}\nPositions: ${gamePositions.length}`);
  return {positions:gamePositions.length,outcome};
    }
    async function trainOnSelfPlay(){ if(!selfPlaySamples.length) return; await ensureModel(); if(!model) return; if(!model.optimizer) model.compile({optimizer:'adam',loss:'meanSquaredError'}); const xs=tf.tensor2d(selfPlaySamples.map(s=>Array.from(s.input))); const ys=tf.tensor2d(selfPlaySamples.map(s=>[s.target])); const before=(()=>{ try{ const w=model.layers[0].getWeights()[0].dataSync(); let s=0; for(let i=0;i<w.length;i++) s+=Math.abs(w[i]); return s; } catch(_){ return 0; } })(); logProgress(progressEl.textContent+'\nTraining on '+selfPlaySamples.length+' samples...'); await model.fit(xs,ys,{epochs:3,batchSize:Math.min(64,selfPlaySamples.length),verbose:0,callbacks:{onEpochEnd:(e,l)=>console.log('[selfplay] epoch',e+1,'loss',Number(l.loss).toFixed(5))}}); xs.dispose(); ys.dispose(); try{ await model.save('indexeddb://tf-chess-eval'); localStorage.setItem('tfEngineModelSaved','1'); }catch(_){ } updateWeights(); const after=(()=>{ try{ const w=model.layers[0].getWeights()[0].dataSync(); let s=0; for(let i=0;i<w.length;i++) s+=Math.abs(w[i]); return s; } catch(_){ return 0; } })(); logProgress(progressEl.textContent+`\nTraining complete. Δ checksum ${(after-before).toFixed(6)}`); selfPlaySamples=[]; }
  async function runSelfPlay(){
    await ensureModel(); if(!model){ logProgress('Model unavailable.'); return; }
    cancelFlag=false; const total=Math.max(1,Math.min(500,parseInt(gamesInput.value,10)||1));
    startBtn.disabled=true; cancelBtn.disabled=false; cancelBtn.style.cursor='pointer'; cancelBtn.style.background='#c24747';
    logProgress('Starting self-play for '+total+' games (training after each game)...');
    if(miniStatusEl) miniStatusEl.textContent='Initializing...';
    for(let g=0; g<total; g++){
      if(cancelFlag){ logProgress('Cancelled at game '+(g+1)); break; }
      const res = await selfPlayOneGame(g,total);
      if(cancelFlag) break;
      if(res){
        if(miniStatusEl) miniStatusEl.textContent='Training game '+(g+1)+'/'+total+'...';
        await trainOnSelfPlay(); // trains on just-finished game's samples
        if(miniStatusEl) miniStatusEl.textContent='Game '+(g+1)+' trained';
        // brief yield so UI updates between games
        await new Promise(r=>setTimeout(r,0));
      }
    }
    if(!cancelFlag && miniStatusEl) miniStatusEl.textContent='Done.';
    startBtn.disabled=false; cancelBtn.disabled=true; cancelBtn.style.background='#777'; cancelBtn.style.cursor='not-allowed';
  }
    if(startBtn) startBtn.addEventListener('click',()=>runSelfPlay());
    if(cancelBtn) cancelBtn.addEventListener('click',()=>{ cancelFlag=true; cancelBtn.disabled=true; cancelBtn.style.background='#777'; cancelBtn.style.cursor='not-allowed'; });
    if(resetBtn) resetBtn.addEventListener('click', async ()=>{ if(!confirm('Reset model weights? This clears all learned adjustments.')) return; await ensureModel(); if(!model) return; model = tf.sequential(); model.add(tf.layers.dense({inputShape:[773],units:96,activation:'relu'})); model.add(tf.layers.dense({units:48,activation:'relu'})); model.add(tf.layers.dense({units:1,activation:'tanh'})); model.compile({optimizer:'adam',loss:'meanSquaredError'}); try{ await model.save('indexeddb://tf-chess-eval'); localStorage.setItem('tfEngineModelSaved','1'); }catch(_){ } updateWeights(); logProgress('Model reset.'); });
  })();
  </script>
</body>
</html>
